import os, time
import numpy
import youtube_dl
import cv2
import tqdm
from moviepy.video.io.VideoFileClip import VideoFileClip
from moviepy.video.io.ImageSequenceClip import ImageSequenceClip
from moviepy.video.fx.all import crop
from moviepy.editor import AudioFileClip, clips_array, TextClip, CompositeVideoClip

from faceoff.faceswap_api import FaceSwapInterface

def read_video_youtube(uri, out_path):
  """
  @return VideoFileClip
  """
  options = {
    'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio',
    'outtmpl': out_path,
    'merge_output_format' : 'mp4'
  }
  with youtube_dl.YoutubeDL(options) as ydl: ydl.download([uri])
  return VideoFileClip(out_path)


def read_video_file(path):
  return VideoFileClip(path)
  


def identity(frame): return frame


def extract_frames(video, out_path, xform=identity):
  """
  Extract and save video frames to out_path. This is done to reduce memory
  footprint.

  @param video A VideoFileClip
  @return None. Used for side-effects (saving frames to out_path)
  """
  if os.path.exists(out_path):
    msg = '[extract_frames] Frames already exist, skipping extraction: {}'
    print(msg.format(out_path))
    return

  os.makedirs(out_path)
  msg = "[extract_frames] Starting on length {}s, at {} fps to {}"
  print(msg.format(video.duration, video.fps, out_path))
  start_time = time.time()

  frame_num = 0
  iterator = video.iter_frames(fps=video.fps)
  for frame in tqdm.tqdm(iterator, total=video.fps * video.duration):
    frame_fd = os.path.join(out_path, 'frame_{:03d}.jpg'.format(frame_num))
    # Apply custom transformation
    frame = xform(frame)
    # Swap RGB to BGR to work with OpenCV
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    cv2.imwrite(frame_fd, frame)
    frame_num += 1

  msg = '[extract_frames] Extracted {} frames in {:.0f}s to {}'
  print(msg.format(frame_num-1, time.time() - start_time, out_path))


def crop_frame(frame):
  """
  Crop video frames generated by faceit. These contain a
  top-bottom display of both the original and the fake. We only want the
  fake, which is on the bottom.

  @param frame A frame of an image, represented as a numpy 2D array
  """
  (h,w,c) = frame.shape
  return frame[int(h/2):h, 0:w]


def extract_faces(frame_path, out_path, face_path, processes=4):
  """
  @param frame_path Path of frames extracted from video
  @param out_path Destination directory
  @param face_path Path to a single image of a face. The face acts as a filter in the extraction process
  """
  if os.path.exists(out_path):
    msg = '[extract_faces] Skipping extraction since faces already exist at {}'
    print(msg.format(out_path))
    return

  os.makedirs(out_path)
  print('[extract_faces] Starting on {}'.format(frame_path))
  start_time = time.time()

  api = FaceSwapInterface()
  api.extract(frame_path, out_path, face_path, processes)


